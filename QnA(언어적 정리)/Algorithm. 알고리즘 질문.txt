(손)코딩

팩토리얼(factorial)을 구현해 보세요(손코딩).
int fact(int n) {
	if (n == 1) return n;
	return n * fact(n - 1);
}
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
	int N = 6;
	int res = 1;
	for (int i = 1; i <= N; i++)
		res *= i;
	cout << res<<endl;
	cout << fact(N);

	return 0;
}


피보나치 수열 구현 방식 세 가지를 말해보시고, 시간복잡도와 공간복잡도를 설명해 주세요.
int fibo1(int n) {
	if (n <= 2) return 1;
	return fibo1(n-1)+ fibo1(n-2);
}

int nFibo[11] = {};
int fibo2(int n) {
	if (n <= 2) return nFibo[n] = 1;
	if (nFibo[n] > 0) return nFibo[n];
	return nFibo[n]= fibo2(n - 1) + fibo2(n - 2);
}
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
	int arr[11] = {};
	arr[1] = arr[2] = 1;
	for (int i = 3; i <= 10; i++)
		arr[i] = arr[i - 1] + arr[i - 2];
	cout << arr[10] << endl;
	cout << fibo1(10) << endl;
	cout << fibo2(10) << endl;

	return 0;
}
BFS/DFS 차이는 무엇인가요?
	각 넓이 우선 탐색, 깊이 우선 탐색으로 
	BFS는 먼저 같은 레벨의 노드를 먼저 방문한 후에 더이상 노드가 없을 경우 아래 다음 레벨 노드로 내갑니다.
	DFS는 먼저 한쪽 자식노드를 모두 탐색하며 최대한 깊게 내려간 후 더이상 노드가 없으면 다른 자식을 탐색합니다.
크루스칼과 프림 알고리즘에 대해서 설명해 주세요.
	크루스칼 알고리즘과 프림알고리즘은 최소비용 신장트리를 구현하는 알고리즘입니다.
	크루스칼 알고리즘은 간선을 오름차순으로 정렬하여 가장 작은 간선부터 차례로 추가하는 방법입니다. 
	이 과정에서 사이클이 생긴다면 건너 뛰게 되는데 사이클을 찾는 방법은 분리 집합을 사용합니다. 간선의 수가 적을 때 유리합니다.
	프림 알고리즘은 정점을 선택하여 그 정점에 연결되어 있는 간선 중 가장 짧은 간선을 선택하여 추가하는 방법으로 간선의 수
	가 많을 때 크루스칼 보다 유리하다. 

다익스트라 알고리즘에 대해서 설명해 주세요.
	지정한 노드에서 모든 노드까지의 최소혹은 최대 비용을 구하는 알고리즘으로 최소 값을 구할 때 각 노드까지의 값을 기본으
	로 무한으로 정한 다음 특정 노드를 거쳐서 가는 값이 더 작을 때 갱신하는 방법으로 구현됩니다.

정렬
정렬의 종류에는 어떤 것들이 있나요?
	기본적인 정렬 방법에는 삽입정렬, 버블정렬, 선택정렬이 있고 퀵 정렬, 병합정렬이 있다.
삽입 정렬이 일어나는 과정을 설명해 보세요.
	N^2의 시간복잡도를 가지며 i=0~N까지 루프를 돌아가며 j=i~0으로 i보다 작은 인덱스 중에서 j의 값과 j-1의 값을 비교하여
	계속하여 바꾸며 j-1이 j보다 작을 때까지 계속한다.
버블 정렬
	삽입정렬과 반대의 개념으로 j와 j+1을 계속 바꾸며 맨 끝에 가장 큰 값을 채우며 정렬하는 것이다. 처음에는 n 두번째는 n-1
	같은 식으로 마지막인덱스를 줄이며 정렬한다.
선택정렬
	i=1~n j=i~n까지 돌아가며 외부 for문에서 선택한 인덱스에 i이후의 값들 중 최소값을 넣는 개념이다.
퀵 정렬이 일어나는 과정을 설명해 보세요.
	pibot을 기준으로 작은 값들은 왼쪽 큰 값들은 오른쪽에 넣어서 0~pibot-1까지 퀵정렬, pibot+1~n까지 퀵정렬하여 분할 정복한다.
54321 배열이 있을 때, 어떤 정렬을 사용하면 좋을까요?
	거의 모든 원소를 정렬해야 하므로 최악의 경우 시간복잡도가 가장 좋은 머지소트가 좋을 것 같다.
랜덤으로 배치된 배열이 있을때, 어떤 정렬을 사용하면 좋을까요?
	일반적으로 퀵소트가 가장 좋다. 알고리즘 자체는 머지소트가 모든경우(NlogN)으로 가장 좋지만 추가적인 공간을 필요하다는 점과 지역성에 있어서 퀵소트가 더 빠르다.
자릿수가 모두 같은 수가 담긴 배열이 있을 때, 어떤 정렬을 사용하면 좋을까요?
	삽입정렬이 가장 좋을 것이다. j가 i부터 시작했을 때 자신보다 더 작거나 같은 원소를 바로 만나 빅오가 O(N)이기 때문이다.