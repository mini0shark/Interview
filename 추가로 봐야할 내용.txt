논리 메모리와 물리 메모리를 분리하는 것의 이점?
운영체제가 물리메모리에 대해 관리하기 때문에 개발자가 물리 메모리에 대해서 신경을 쓰지않고 개발에만 집중 할 수 있다.
또한, 요구페이징을 통해 메모리의 크기보다 용량이 큰 프로그램을 실행시킬 수 있다.

순수 요구페이징에 따르면 성능 저하가 발생할 수 있는데 어떤 특성때문에 괜찮다고 하는지?
지역의 참조성. 실질적으로 성능저하가 없다.

micro 코드
미리 두 블럭이 깨지는 것을 막는다.


요구 페이징의 성능을 높이려면 무엇을 신경써야 하고 그래서 어떤 알고리즘을 신경써야 할까요?
페이지의 성능을 높이려면 페이지 fault에서 성능을 높여야하고 페이지 교체 알고리즘과 페이지 할당 알고리즘이 중요하다.

스레싱의 정의
저성능, 소량의 core 사용 → 저성능 CPU/core 사용
메모리 해제 문제(exit(), G/C 문제 등)  → 메모리 누수, 좀비 프로세스 등


-워킹셋
-PFF


메켄지


==================================
라우터, ISP
HTTP 요청에 대한 캐시가 있을 때의 처리 과정
DHCP
터널링
캐싱


아파치 톰캣 웹서버

웹서버와 was에 대해 설명해 주세요




==========================================================

DNS 프로토콜
RIP 프로토콜
SNMP 프로토콜


http/2
http/3
quick


보안관련

웹소켓


http 에 대해
요청 응답 구조를 설명해보세요


네이버를 쳤을 때 네트워크 상에서 생기는 일

ssl, 트래픽제어(로드 밸런싱)


==========================================================

함수형 프로그래밍-> 수학에서의 함수로 프로그래밍 하는 
ㅇㄹㅇㄴㅁㄴㅇ


객체지향 프로그래밍에서 캡슐화를 통해 얻을 수 있는 장점은?
데이터와 처리함수를 묶는 것으로 캡슐화를 하게되면 재사용이 용이하고, 정보은닉을 하기위한 발판을 마련할 수 있습니다.

정보은닉을 해야하는 이유?어차피 프로그래머가 같은데 외부에서 접근 못할텐데 정보은닉을 해야하는 이유가 뭐에요?
 정보은닉을 통하여 더욱 객체지향적인 특성을 지킬 수 있기 때문입니다. 정보은닉을 통해 객체가 가지고 있는 데이터, 기능 뿐아니라 궁극적으로는 객체 자체를 숨김으로써 해당 객체에 대한 의존성을 낮춤으로 인해 각 객체마다 독립성과 유동성을 높일 수 있습니다.


객체끼리 관계를 맺고 있어야하는데 객체가 삭제된다면 어떻게 그 관계가 어떻게 유지 될수 있나요?
Bridge패턴이라는 디자인 패턴을 이해하면 됩니다. 브릿지 패턴은 어떤 객체를 접근할때 직접접근하는것이 아니라 그 객체가 구현한 interface에 접근을 하여 직접적인 접근을 하지 않더라도 접근 할 수 있도록 하여 객체가 수정 혹은 삭제되거나 심지어 작성되지 않은 상태더라도 관계를 유지할 수 있습니다.

객체지향이 유지보수가 편하고 이런 장점이 있는데 절차지향 언어를 사용하는 이유는?
프로그램의 크기가 적을 때는 절차지향 프로그래밍이 더 유리할 수 있습니다. 또한, 객체지향보다 기계 친화적이기 때문에 더 빠른 속력을 낼 수 있다는 장점이 있습니다.




정보은닉은 객체지향을 통해 유연성을 가능하게 하는 전략이다. 객체, 상속, 캡슐화 등은 은닉의 수단에 불과하다. 정보은닉은 잘된 추상화를 통해 얻어진다.

캡슐화를 정보은닉이라고 하지만 이것은 정확한 말이 아니다.

캡슐화는 정보은닉을 구현하는 수단일 뿐이다. 정보은닉이란 모든 객체지향 언어적 요소를 활용하여 객체에 대한 구체적인 정보를 노출시키지 않도록 하는 기법이다.


소프트웨어의 유연성을 확보하는 방법은 "객체간에 서로를 모르게 하는 것"이다. 두 객체가 서로를 모른다는 것은 서로의 코드에 상대 객체나 클래스에 대한 코드가 한줄도 없다는 것을 의미한다. 이는 둘 중 하나가 수정되거나 사라져도 다른 객체는 영향을 받지 않는 것을 의미하고 두 객체 사이에는 유연성이 확보된다는 것을 의미한다.
 
하지만 이를 전체 시스템에 확장 시킬 수는 없다. 객체지향 언어에서 목적을 달성하기 위해서는 필연적으로 다른 객체와의 협력이 있어야하고, 모든 객체들은 어떤 형태로든 관계를 맺어야 하기 때문이다. 객체를 노드로, 관계를 엣지로 나타낸다면 한덩어리의 연결 그래프가 되어야하며 다른 객체와 관계를 맺지 않는 객체가 있다면 이는 하나의 별도 시스템이다.

따라서 필연적으로 관계를 맺어야한다면 똑같은 관계라도 더 좋은 관계로 변경해야한다. 다음은 좋은 관계에 대한 예시이다.

1. 자주 변경될 가능성이 있는 것에는 의존하지 않는다.
2. 외부로 노출된 메소드를 최소한으로 줄인다. 노출된 메소드가 최소인 객체는 노출된 메소드가 많은 객체에 비해 메소드가 적게 호출되고, 이는 다른 객체와의 관계가 발생할 가능성을 줄인다.
3. 객체의 책임을 최소한으로 줄인다. 책임이 작은 객체는 다른 객체와의관계가 작아진다. 책임이 작아진 객체는 또한 수정될 가능성이 줄어든다. 따라서 다른 객체에 ㄷ수정의 영향을 줄 가능성도 줄어든다.

정보 은닉의 종류
- 객체의 구체적인 타입 은닉(=상위 타입 캐스팅)
- 객체의 필드 및 메소드 은닉(=캡슐화)
- 구현 은닉(=인터페이스 및 추상 클래스 기반의 구현)


정보 은닉의 목적
- 코드가 구체적인 것들(타입, 메소드, 구현)에 의존하는 것을 막아줌으로써 객체간의 구체적인 결합도를 약화시켜 기능의 교체나 변경이 쉽도록 함.
- 동일한 타입의 다른 구현 객체들을 교체함으로써 동적 기능 변경이 가능함.(인터페이스)
- 연동할 구체적인 구현이 없는 상태에서도 정확한 연동 코드의 생성이 가능함.(인터페이스)

이처럼 인터페이스와 구현을 분리하면 다음과 같은 이점이 있다.

- Interface만으로 객체를 다룰 수 있으므로 구체적인 구현에 대해서 전혀 모르더라도 동작이 가능하다. 즉 구현에 대해 관심을 둘 필요가 없다.

- 좀 더 나가보면 Interface만 알고 있어도 Interface에 의존하는 코드를 작성할 수가 있다. 즉, Interface를 상속 받는 임시 객체를 만들어 두고 이를 이용하는 코드들을 만들었다가 추후에 Interface를 구현한 구체 클래스가 완성되었을 때 연결만 시켜주면 된다.





https://effectiveprogramming.tistory.com/entry/객체지향-정보-은닉information-hiding에-대한-올바른-이해




===========================================

가상 메모리란?
메모리에 로드된, 실행중인 프로세스가 메모리가 아닌 가상의 공간을 참조해 마치 커다란 물리 메모리를 갖는 것처럼 사용할 수 있게 해주는 기법

가상메모리란?
프로세스에서 사용하는 메모리 주소와 실제 물리적 메모리 주소는 다를 수 있음

따라서 메모리 = 실제 + 가상 메모리라고 생각하면 안됨

메모리가 부족해서 가상메모리를 사용하는 건 맞지만, 가상메모리를 쓴다고 실제 메모리처럼 사용하는 것은 아님

실제 메모리 안에 공간이 부족하면, 현재 사용하고 있지 않은 데이터를 빼내어 가상 메모리에 저장해두고, 실제 메모리에선 처리만 하게 하는 것이 가상 메모리의 역할이다.

즉, 실제 메모리에 놀고 있는 공간이 없게 계속 일을 시키는 것. 이를 도와주는 것이 '가상 메모리'





(동기화)
뮤텍스, 세마포어가 뭔지, 차이점은?
#세마포어
운영체제에서 공유 자원에 대한 접속을 제어하기 위해 사용되는 신호 공유자원에 접근할 수 있는 최대 허용치만큼만 동시에 사용자 접근 가능 스레드들은 리소스 접근 요청을 할 수 있고, 세마포어는 카운트가 하나씩 줄어들게 되며 리소스가 모두 사용중인 경우(카운트=0) 다음 작업은 대기를 하게 된다

#뮤텍스
상호배제, 제어되는 섹션에 하나의 스레드만 허용하기 때문에, 해당 섹션에 접근하려는 다른 스레드들을 강제적으로 막음으로써 첫번재 스레드가 해당 섹션을 빠져나올 때까지 기다리는 것 (대기열(큐) 구조라고 생각하면 됨)

#차이점
세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없음
세마포어는 소유 불가능하지만, 뮤택스는 소유가 가능함
동기화의 개수가 다름